<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Scientific Computing in Practice 2015 Day 2: Debugging, Profiling, Optimizing</title>

		<meta name="description" content="Scientific Computing in Practice 2015 Day 2 Supplemental slides">
		<meta name="author" content="Janne Blomqvist">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section data-markdown>
					<script type="text/template">
					  # Scientific Computing in Practice 2015
					  ## Day 2
					  ### Low level dig down

					  Janne Blomqvist
					
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
					  Richard Darst has explained the basics of debugging, profiling, and optimizing using python. What follows here is an overview of what additional issues needs to be taken into account when working with lower level languages like C, C++, or Fortran, as well as an introduction to useful tools for these languages.

					  - On language choice
					  - Brief introduction to modern CPU and memory architectures
					  - Using the GNU debugger
					  - Using the perf profiler
					  - MPI debugging and profiling tools on Triton
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
					  # On language choice

					  ### Holy war time!

					  Typically, programming languages can be classified into high level and low level languages.

					  - High level languages such as Python emphasise programmer productivity, typically at the expense of performance.
					  - Low level languages such as C, C++, Fortran tend to be somewhat more aligned with how the hardware operates, and often lack safety features.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
					  ### Why not both high productivity and high performance?
					  
					  Indeed, why not?

					  See [Julia](http://julialang.org/) for a language that tries to do both, with an emphasis on technical computing. Available on triton via the module system. Typical performace roughly within a factor of 2 of C. How is it possible?

					  - Careful language design to create a high level dynamic language that can still be efficiently executed.
					  - Type inferencing to avoid (most) type dispatch at runtime.
					  - Just-in-Time (JIT) compiled to machine code rather than interpreted.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
					  # Brief introduction to CPU and memory architecture

					  
					  - A brief history of recent trends in microprocessor design
					  - What are the relevant factors today affecting performance?
					  
					  
					</script>
				</section>

				<section>
				  von Neumann architecture: Abstract model of how a computer works:

				  <img src="1000px-Von_Neumann_Architecture.svg.png" style="background-color:white;">

				</section>

				<section data-markdown>
					<script type="text/template">
					  Modern processors are vastly complicated, with lots of features to increase performance

					  - Pipelined execution
					  - Superscalar
					  - Multiple levels of cache
					  - Branch prediction and speculative execution
					  - Prefetching
					  - Out-of-Order Execution
					  - SIMD instructions
					  - etc.
					</script>
				</section>

				<section>
				  <img src="CPU.png" width="435" height="434" style="background-color:white;">
				</section>

				<section>
				  <h5>Latency Comparison Numbers (Jeff Dean, Google)</h5>
<code><pre>
L1 cache reference                            0.5 ns
Branch mispredict                             5   ns
L2 cache reference                            7   ns  14x L1 cache
Mutex lock/unlock                            25   ns
Main memory reference                       100   ns  20x L2 cache, 200x L1 cache
Compress 1K bytes with Snappy/LZ4         3,000   ns
Send 1K bytes over 1 Gbps network        10,000   ns  Triton IB network A LOT faster
Read 4K randomly from SSD*              150,000   ns
Read 1 MB sequentially from memory      250,000   ns
Round trip within same datacenter       500,000   ns  Triton IB network 5000ns
Read 1 MB sequentially from SSD*      1,000,000   ns
Disk seek                            10,000,000   ns
Read 1 MB sequentially from disk     20,000,000   ns
Send packet CA->Netherlands->CA     150,000,000   ns
</pre></code>

				</section>

				<section data-markdown>
					<script type="text/template">
					  Low level optimization these days is mostly about avoiding stalling on accessing main memory.

					  In HPC, vectorization can also be important. Increasingly so with newer processors.
					</script>
				</section>

				<section data-markdown>
					<script type="text/template">
					  # References

					  - Hennessy, Patterson: Computer Architecture: A Quantitative Approach. 
					  - [Ulrich Drepper: What Every Programmer should know about memory](http://akkadia.org/drepper/cpumemory.pdf)
					  - [Sutter: The free lunch is over](http://www.gotw.ca/publications/concurrency-ddj.htm)
					</script>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
